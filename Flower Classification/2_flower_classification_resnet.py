# -*- coding: utf-8 -*-
"""2. Flower Classification_RESNET.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TvL65NZeunW2uaiTssobFVq7ClF8LeUP

## **Probelm Statement**
The objective of this case study is to predict the class of flower using computer vision techniques such as CNN and RESNET.

## **Importing necessary libraries**
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import os
import PIL #PIL stands for Python Imaging Library. It is used to process image in different format using Python
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Flatten, Dense
from tensorflow.keras.optimizers import Adam

"""## **Downloading Dataset**
I have used tf.keras.utils.get_file to download the data in keras cache directory using pathlib module.
"""

import pathlib
dataset_url = "https://storage.googleapis.com/download.tensorflow.org/example_images/flower_photos.tgz"
data_dir = tf.keras.utils.get_file('flower_photos', origin=dataset_url, untar=True)
data_dir = pathlib.Path(data_dir)

"""## **Creating training and validation subset**
Spliting the dataset into training and validation with train and validation split of 80:20
"""

# Defining batch_size, height and width of image
batch_size = 32
img_height = 180
img_width = 180

train_ds = tf.keras.preprocessing.image_dataset_from_directory(
    data_dir,
    validation_split=0.2,
    subset='training',
    seed=123,
    image_size=(img_height,img_width),
    batch_size=batch_size
)

val_ds = tf.keras.preprocessing.image_dataset_from_directory(
    data_dir,
    validation_split=0.2,
    subset='validation',
    seed=123,
    image_size=(img_height,img_width),
    batch_size=batch_size
)

"""## **Visualizing the data**"""

class_names = train_ds.class_names
print(class_names)

# Set up the figure size
plt.figure(figsize=(10, 10))

# Loop through the first batch of images and labels
for images, labels in train_ds.take(1):
    # Loop through the first 9 images
    for i in range(9):
        # Create a subplot for each image
        ax = plt.subplot(3, 3, i + 1)

        # Display the image
        plt.imshow(images[i].numpy().astype('uint8'))

        # Set the title of the image
        plt.title(class_names[labels[i]])

        # Turn off the axis
        plt.axis("off")

"""## **Using RESNET for flower classification**
The deep learning architecture became deeper and deeper (adding more layers) to solve more and more complex tasks which also helped in improving the performance of classification and recognition tasks and also making them robust. But when we go on adding more layers to the neural network, it becomes very difficult to train and the accuracy of the model starts saturating and then degrades which is the case seen in the CNN. Here comes the ResNet to rescue from that scenario, and helps to resolve the problem.

Below I am using pre-trained model for ResNet and we have added sense and flatten layers for the pretrained model then compiling the model and then displaying model summary to see the total number of trainable and non-trainable parameters.
"""

resnet_model = Sequential()
pretrained_model = tf.keras.applications.ResNet50(
    include_top=False, weights='imagenet', input_shape=(180,180,3), pooling='avg')

for layer in pretrained_model.layers:
    layer.trainable=False

resnet_model.add(pretrained_model)
resnet_model.add(Flatten())
resnet_model.add(Dense(512, activation='relu'))
resnet_model.add(Dense(5, activation='softmax'))

# Compile the model:
resnet_model.compile(optimizer=Adam(learning_rate=0.001),
                     loss='sparse_categorical_crossentropy',
                     metrics=['accuracy'])

resnet_model.summary()

"""## **Training the model using epochs**
I am using 10 epochs to train the model and for each epoch will check the model's training and validation accuracy with the corresponding loss.
"""

epochs = 10
history = resnet_model.fit(train_ds, validation_data=val_ds, epochs=epochs)

"""## **Plotting graph for comparision of training and validation accuracy**"""

fig1 = plt.gcf()
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.ylim(0.4, 1)  # Set the y-axis limits directly using plt.ylim()
plt.grid()
plt.title('Model Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epochs')
plt.legend(['train', 'validation'])
plt.show()

"""It is clearly seen that using RESNET our validation accuracy has improved and it is close to 90% where as it was not even 70% when the model built using CNN model. Hence, RESNET has outperformed CNN model when dealing with the large dataset of images.

## **Visualizing images using cv2**
OpenCV-Python is a library of python bindings designed to solve computer vision problems. cv2.imshow() method is used to display an image in a window. The window automatically fits the image size.
"""

import cv2
roses = list(data_dir.glob('roses/*'))
image = cv2.imread(str(roses[0]))
image_resized = cv2.resize(image, (img_height,img_width))
image_1 = np.expand_dims(image_resized,axis=0)

PIL.Image.open(str(roses[0]))

daisy = list(data_dir.glob('daisy/*'))
image = cv2.imread(str(daisy[0]))
image_resized = cv2.resize(image, (img_height,img_width))
image_2 = np.expand_dims(image_resized,axis=0)

PIL.Image.open(str(daisy[0]))

"""## **Predicting Results**
ResNet model is used to predict the results on the dataset
"""

pred_1 = resnet_model.predict(image_1)
pred_2 = resnet_model.predict(image_2)

output_class = class_names[np.argmax(pred_1)]
print("The predicted class is ", output_class)

output_class = class_names[np.argmax(pred_2)]
print("The predicted class is ", output_class)

"""## **Conclusion**
It's clearly seen that after using ResNet the validation accuracy has improved and it close to 90% where as it was not even 70% when the model was built using CNN model. Hence, ResNet has outperformed CNN model when dealing with the large dataset of images.
"""



